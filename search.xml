<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构之AVL树]]></title>
    <url>%2F2019%2F10%2F13%2FAVL%2F</url>
    <content type="text"><![CDATA[上节了解了二叉查找树，我们知道，二叉查找树的缺点是会出现一边倒（“瘸腿”）的情况。这种情况让二叉查找树的查找效率大打折扣，于是出现了自平衡二叉查找树（AVL树），它能通过一定机制保证二叉查找树的平衡。AVL树的特点12具有二叉查找树的全部特性每个节点的左子树和右子树的高度差至多等于1图一、图二为两颗二叉查找树（节点旁的红色数字是当前节点的高度），图一的BST符合AVL的特性（节点8的左孩子高度2与右孩子高度0相差1），所以是一颗AVL树；而图二的树不符合AVL树的特性（节点8的左孩子高度2与右孩子高度0相差2），要让它成为一颗AVL树，就需要对其进行变化。 AVL树的旋转旋转总共有四种形式：右旋、左旋、左右双旋、右左双旋 为什么要旋转不管什么形式的旋转，旋转的目的是为了降低树的高度，使其平衡。 右旋假如我们在节点插入的时候，出现了节点都倾向于左边的情况，例如：我们把这种倾向于左边的情况称为左-左型。这个时候，我们可以对节点8进行右旋操作，使它恢复平衡。即：以旋转节点为轴，顺时针旋转，使得自己被自己的左孩子取代，自己成为左孩子的右孩子，原来左孩子的右孩子成为自己的左孩子。看一个动图：再看一个例子：节点5和10的高度差大于1，由于5的左孩子高度较高，所以此种情况是左-左型，对节点8进行右旋。注意：节点6的变化！ 左旋假如我们在节点插入的时候，出现了节点都倾向于右边的情况，例如：这种倾向被我们称为右-右型，我们对节点10进行左旋操作。即：以旋转节点为轴，逆时针旋转，使得自己被自己的右孩子取代，自己成为右孩子的左孩子，原来右孩子的左孩子成为自己的右孩子。看一个动图：看一个例子：节点2和6的高度差大于1，由于6的右孩子高度较高，所以此种情况是右-右型，对节点4进行左旋。注意：节点5的变化！ 左右双旋如果我们在节点插入时出现这种状况，我们该怎么办呢？很显然，我们无法通过一次左旋或右旋来解决，下面来说说如何解决。我们就称它为右-左型吧，处理方法是先对节点10进行右旋。右旋后，我们发现树的结构变成了右-右型，于是我们再对节点7进行左旋。通过两次旋转，我们发现树平衡了。注意：两次旋转节点是不一样的！！！看一个例子：节点2和6的高度差大于1，由于6的左孩子高度较高，所以此种情况是右-左型。注意：节点4的变化！ 右左双旋我们就称它为左-右型吧，处理方法是先对节点5进行左旋。左旋后，我们发现树的结构变成了左-左型，于是我们再对节点8进行右旋。看一个例子：节点5和10的高度差大于1，由于5的右孩子高度较高，所以此种情况是左-右型。注意：节点7的变化！ 总结在插入过程中，会出现以下四种情况破坏AVL树的特性，我们可以采取如下相应的旋转: 左-左型：做右旋 右-右型：做左旋 左-右型：先做左旋，再做右旋 右-左型：先做右旋，再做左旋]]></content>
      <categories>
        <category>Data Structure</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>AVL Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之二叉查找树BST]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F</url>
    <content type="text"><![CDATA[在复习数据结构时，觉得有必要将这个内容记录下来，也查了一些资料、博客，做一下总结。在下节说AVL树之前，我们先说一下二分查找树（BST）。二叉搜索树（二叉查找树）特点如下：123若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值。若它的右子树不为空，则右子树上所有的节点值都大于它的根节点值。它的左右子树也分别可以充当为二叉查找树。 例如： 优点：可以让我们快速找到想要找到的值。 例如，我们想找到11这个数。根据二叉查找树的特性，我们查找的过程如下： 和根节点8比较 因为11&gt;8， 所以11只会在节点8的右子树中，我们查看右孩子10 因为11&gt;10，继续查看10的右孩子13 因为11&lt;13，所以11只会在13的左子树中，查看左孩子11 我们发现11正好是想要查找的值，于是结束查找。 二叉查找树的这种查找正是二分查找的思想，我们可以很快的找到目的节点，最大查找次数等于树的高度。 插入的时候，也是通过一层一层，找到适合自己的位置插入。 缺点：可能会出现一种一边倒的极端情况。 例如，给定一颗初始二叉查找树： 接着，我们陆续插入3、2、1、0 我们可以明显的看到节点倾向一边。这种形态的二叉查找树在查找性能上，就大打折扣，几乎变成线性。 节点删除：删除节点，可能会存在三种情况，这三种情况分别如下： 没有左右子节点，可以直接删除 存在左节点或右节点，删除后需要对子节点进行移动 同时存在左节点和右节点，不能简单的删除，但是可以通过和后继节点交换后转换为前两种情况 我们将使用图进行解释，初始状态如下图。 我们会按照上面所述三种情况来解释。 1. 没有左右子节点在图中，符合这种状况的节点有25,42,55,80,95， 我们随便拿一个节点95来演示删除该节点：删除后，如下图：这种情况是最简单的，只需要删除该节点以及该节点和父节点的关系即可。 2. 存在左节点或者右节点时在图中，符合这个情况的节点有45,75两个节点，我们拿75来演示：删除后，如下图：这种情况，需要断两个关系，然后建立其父节点与子节点的关系。 3. 同时存在左右节点在图中，满足这个情况的节点有60,40,90,50这4个节点，我们以40为例：当二叉查找树以中根序遍历时，遍历的结果是从小到大排列的顺序，如下图所示：当我们删除40节点的时候，整个中根序遍历的结果中，从42开始都往前移动了一位。42是40的后继节点，也就是比40大的节点中最小的节点。当某个节点存在右节点时，后继节点就是右节点中的最小值，左侧节点总比右侧节点和父节点小，所以后继节点一定没有左节点。后继节点还有一个特点，就是他比40的左节点大，比40所有的右节点都小。 因此，删除40的时候，可以直接将后继节点42的值赋给40节点，然后删除后继节点42。由于后继节点最多只有一个子节点，因此删除后继节点又变成了前两种情况。图示如下：]]></content>
      <categories>
        <category>Data Structure</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java遍历Map容器的两种方法]]></title>
    <url>%2F2019%2F09%2F16%2FJava%E9%81%8D%E5%8E%86Map%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在Map容器中：values():获取容器中的所有的值，没有键，没有对应关系KeySet():将Map中所有的键存入到Set容器中，因为Set具备迭代器。所以可以迭代取出所有的键，再根据get方法，获取每一个键对应的值。KeySet()迭代后，只能通过get()取key。entrySet():Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() //返回此映射中包含的映射关系的Set视图。Map.Entry表示映射关系。entrySet()迭代后，可以通过e.getKey(), e.getValue()获取key和value。返回的是Entry接口。 一、两种遍历Map的方式1.通过KeySet()遍历 1234for(Iterator&lt;Integer&gt; iter = keySetMap.keySet().iterator(); iter.hasNext();) &#123; Integer key = iter.next(); System.out.println(key + “----“ + keySetMap.get(key)); &#125; 2.通过entrySet()遍历 1234for(Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iter = entrySetMap.entrySet().iterator(); iter.hasNext();) &#123; Map.Entry&lt;Integer, String&gt; temp = iter.next(); System.out.println(temp.getKey() + “--“ + temp.getValue()); &#125; ps: 两种方法都使用了迭代器，for循环的初始化条件总是为初始化一个Iterator，利用Iterator的hasNext()方法判断是否遍历结束，再利用next()方法获取下一个对象。 二、两种方法性能对比测试代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; keySetMap = new HashMap&lt;&gt;(); HashMap&lt;Integer, String&gt; entrySetMap = new HashMap&lt;&gt;(); for(int i = 0; i &lt; 5000; i++) &#123; keySetMap.put(i, "a" + i); &#125; for(int i = 0; i &lt; 5000; i++) &#123; entrySetMap.put(i, "a" + i); &#125; //第一种遍历Map的方式 long startTime1 = System.currentTimeMillis(); for(Iterator&lt;Integer&gt; iter = keySetMap.keySet().iterator();iter.hasNext();) &#123; Integer key = iter.next(); System.out.print(key + "----" + keySetMap.get(key) + ","); &#125; long endTime1 = System.currentTimeMillis(); System.out.println("++++++++++++++++++++++++++++++++++"); //第二种遍历Map的方式 long startTime2 = System.currentTimeMillis(); for(Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter = entrySetMap.entrySet().iterator(); iter.hasNext();) &#123; Map.Entry&lt;Integer,String&gt; temp = iter.next(); System.out.print(temp.getKey() + "--" + temp.getValue() + ","); &#125; long endTime2 = System.currentTimeMillis(); System.out.println(); System.out.println("第一种遍历耗时：" + (endTime1 - startTime1) + "ms"); System.out.println("第二种遍历耗时：" + (endTime2 - startTime2) + "ms"); &#125;&#125; 在上述程序中，我们创建了包含5000个对象的Set容器。对容器分别用KeySet()和entrySet()进行遍历。观察遍历运行结果，进行比较。 观察第一遍程序运行结果： 观察第二遍程序运行结果： 可以看到，entrySet()比KeySet()的运行时间少很多，多次运行程序，总是如此(如上图，只截取了两次)。 为什么两种方法的性能差异这么大呢？再次观察两种遍历方法。 1234for(Iterator&lt;Integer&gt; iter = keySetMap.keySet().iterator(); iter.hasNext();) &#123; Integer key = iter.next(); System.out.println(key + “----“ + keySetMap.get(key)); &#125; 1234for(Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iter = entrySetMap.entrySet().iterator(); iter.hasNext();) &#123; Map.Entry&lt;Integer, String&gt; temp = iter.next(); System.out.println(temp.getKey() + “--“ + temp.getValue()); &#125; 可以看到，两种方法都是先通过迭代器遍历Map，此时，二者的性能应该是相同的。 而差距体现在打印时： 1. keySet()是通过获取到的key再次去Map中遍历寻找相对应的value(相当于遍历了两次)。 2. 而entrySet中直接通过getKey()和getValue()获取key和value(相当于遍历了一次)。]]></content>
      <categories>
        <category>Java</category>
        <category>collection</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
        <tag>Iterator</tag>
        <tag>Map</tag>
      </tags>
  </entry>
</search>
